# Production-Grade E-Commerce Microservices Testing & Monitoring Guide

## Architecture Overview

```
┌─────────────────────────────────────────────────────────────┐
│                    Istio Ingress Gateway                     │
│                         (mTLS)                               │
└──────────────────────┬─────────────────────────────────────┘
                       │
       ┌───────────────┼───────────────┐
       │               │               │
   ┌───▼────┐    ┌────▼───┐      ┌───▼────┐
   │Product │    │ Cart   │      │ User   │
   │Service │    │Service │      │Service │
   │v1 (90%)│    │        │      │        │
   │v2 (10%)│    └────┬───┘      └────────┘
   └───┬────┘         │
       │              │
       │         ┌────▼─────┐
       │         │Inventory │
       │         │ Service  │
       │         └──────────┘
       │
   ┌───▼────────┐
   │   Order    │
   │  Service   │
   └───┬────────┘
       │
       ├────────┬────────┬─────────┐
       │        │        │         │
   ┌───▼───┐┌──▼───┐┌───▼────┐┌───▼──────┐
   │Payment││Ship- ││Invento-││Notifica- │
   │Service││ping  ││ry      ││tion      │
   │       ││Svc   ││Service ││Service   │
   └───────┘└──────┘└────────┘└──────────┘
```

## Service Mesh Features

### 1. mTLS (Mutual TLS) Verification

```bash
# Check mTLS status for all services
istioctl authn tls-check -n ecommerce

# Expected output: All services should show STRICT mode
# This means all service-to-service communication is encrypted

# View mTLS configuration
kubectl get peerauthentication -n ecommerce -o yaml

# Test encrypted communication
kubectl exec -n ecommerce deploy/product-service-v1 -c product-service -- \
  curl -s http://cart-service:8080/api/cart/user123
```

### 2. Canary Deployment Testing

```bash
# View current traffic split
kubectl get virtualservice product-canary -n ecommerce -o yaml

# Test traffic distribution (100 requests)
for i in {1..100}; do
  curl -s http://$GATEWAY_URL/api/products | jq -r '.version'
done | sort | uniq -c

# Expected: ~90 v1, ~10 v2

# Force traffic to v2
curl -H "x-version: v2" http://$GATEWAY_URL/api/products

# Monitor canary metrics in Grafana
# Dashboard: Istio Service Dashboard
# Filter by: product-service, group by version
```

### 3. Circuit Breaker Testing

```bash
# Generate load to trigger circuit breaker
for i in {1..50}; do
  curl -X POST http://$GATEWAY_URL/api/orders \
    -H "Content-Type: application/json" \
    -d '{"userId":"1","items":[{"productId":"1","price":999,"quantity":1}]}' &
done
wait

# Check circuit breaker stats
kubectl exec -n ecommerce deploy/payment-service -c istio-proxy -- \
  pilot-agent request GET stats | grep payment-service | grep -E "(outlier|ejection)"

# View ejected hosts
kubectl exec -n ecommerce deploy/order-service -c istio-proxy -- \
  pilot-agent request GET clusters | grep payment-service

# Expected behavior:
# - Failing instances get ejected after 3 consecutive errors
# - Traffic redistributed to healthy instances
# - Ejected instances reinstated after 30s base ejection time
```

### 4. Fault Injection Demo

#### Scenario A: Inject 5s Delay (50% of requests)

```bash
# Apply delay fault
kubectl apply -f - <<EOF
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: payment-service
  namespace: ecommerce
spec:
  hosts:
  - payment-service
  http:
  - fault:
      delay:
        percentage:
          value: 50.0
        fixedDelay: 5s
    route:
    - destination:
        host: payment-service
EOF

# Test with timing
for i in {1..10}; do
  echo "Request $i:"
  time curl -X POST http://$GATEWAY_URL/api/orders \
    -H "Content-Type: application/json" \
    -d '{"userId":"1","items":[{"productId":"1","price":999,"quantity":1}]}'
  echo "---"
done

# Expected: ~50% of requests take 5+ seconds
# Watch Jaeger traces to see delay impact

# Remove fault
kubectl delete virtualservice payment-service -n ecommerce
```

#### Scenario B: Inject HTTP 503 Errors (30% of requests)

```bash
# Apply abort fault
kubectl apply -f - <<EOF
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: payment-service
  namespace: ecommerce
spec:
  hosts:
  - payment-service
  http:
  - fault:
      abort:
        percentage:
          value: 30.0
        httpStatus: 503
    route:
    - destination:
        host: payment-service
EOF

# Test error rate
success=0
failures=0
for i in {1..50}; do
  status=$(curl -s -o /dev/null -w "%{http_code}" -X POST \
    http://$GATEWAY_URL/api/orders \
    -H "Content-Type: application/json" \
    -d '{"userId":"1","items":[{"productId":"1","price":999,"quantity":1}]}')
  
  if [ "$status" = "201" ]; then
    ((success++))
  else
    ((failures++))
  fi
done

echo "Success: $success, Failures: $failures"
# Expected: ~35 success, ~15 failures (accounting for retries)

# Remove fault
kubectl delete virtualservice payment-service -n ecommerce
```

### 5. Retry Policy Verification

```bash
# The retry policy is configured to attempt 3 retries on 5xx errors

# View retry configuration
kubectl get virtualservice payment-retry -n ecommerce -o yaml

# Test retries with fault injection
kubectl apply -f - <<EOF
apiVersion: networking.istio.io/v1beta1
kind: VirtualService
metadata:
  name: payment-service
  namespace: ecommerce
spec:
  hosts:
  - payment-service
  http:
  - fault:
      abort:
        percentage:
          value: 50.0
        httpStatus: 503
    route:
    - destination:
        host: payment-service
    retries:
      attempts: 3
      perTryTimeout: 2s
      retryOn: 5xx,reset,connect-failure
EOF

# Make requests and observe retries in Jaeger
curl -X POST http://$GATEWAY_URL/api/orders \
  -H "Content-Type: application/json" \
  -d '{"userId":"1","items":[{"productId":"1","price":999,"quantity":1}]}'

# Check Jaeger trace for multiple spans to payment service
# Open Jaeger UI and search for recent order traces
```

## Observability

### Kiali - Service Mesh Visualization

```bash
kubectl port-forward -n istio-system svc/kiali 20001:20001
# Open: http://localhost:20001

# What to look for:
# 1. Graph view: Shows service topology and real-time traffic
# 2. Traffic rates (requests/sec)
# 3. Error rates (red edges indicate errors)
# 4. Response times (color coding)
# 5. mTLS indicators (padlock icons)

# Generate traffic to visualize
for i in {1..1000}; do
  curl -s http://$GATEWAY_URL/api/products > /dev/null
  curl -s http://$GATEWAY_URL/api/products/1 > /dev/null
  sleep 0.1
done
```

### Grafana - Metrics & Dashboards

```bash
kubectl port-forward -n istio-system svc/grafana 3000:3000
# Open: http://localhost:3000

# Key Dashboards:
# 1. Istio Service Dashboard
#    - Request volume
#    - Success rate
#    - Request duration (p50, p90, p99)
# 
# 2. Istio Mesh Dashboard
#    - Global request volume
#    - Global success rate
#    - Service-to-service latency
#
# 3. Istio Performance Dashboard
#    - Pilot/Envoy performance
#    - Configuration sync status

# Custom Queries (Prometheus):
# Request rate by service:
sum(rate(istio_requests_total{destination_service_namespace="ecommerce"}[1m])) by (destination_service_name)

# Error rate:
sum(rate(istio_requests_total{destination_service_namespace="ecommerce",response_code=~"5.*"}[1m])) by (destination_service_name)

# P99 latency:
histogram_quantile(0.99, sum(rate(istio_request_duration_milliseconds_bucket{destination_service_namespace="ecommerce"}[1m])) by (le, destination_service_name))
```

### Jaeger - Distributed Tracing

```bash
kubectl port-forward -n istio-system svc/tracing 16686:16686
# Open: http://localhost:16686

# Search for traces:
# Service: order-service.ecommerce
# Operation: all
# Lookback: Last 1 hour

# What to analyze:
# 1. End-to-end request flow
# 2. Time spent in each service
# 3. Failed requests and where they failed
# 4. Retry attempts
# 5. Parallel vs sequential calls

# Create a trace to analyze
curl -X POST http://$GATEWAY_URL/api/orders \
  -H "Content-Type: application/json" \
  -d '{"userId":"1","items":[{"productId":"1","price":999,"quantity":1}]}'

# Expected trace spans:
# 1. istio-ingressgateway → order-service
# 2. order-service → payment-service
# 3. order-service → inventory-service (if implemented)
# 4. order-service → shipping-service
# 5. order-service → notification-service
```

## Load Testing

### Generate Realistic Traffic

```bash
# Create load test pod
kubectl run loadtest -n ecommerce --image=busybox --restart=Never -- sleep 3600

# Simple load test
kubectl exec -n ecommerce loadtest -- /bin/sh -c '
for i in $(seq 1 1000); do
  wget -q -O- http://product-service:8080/api/products
  wget -q -O- http://cart-service:8080/api/cart/user$((RANDOM % 100))
  sleep 0.1
done
'

# Complex order flow load test
kubectl exec -n ecommerce loadtest -- /bin/sh -c '
for i in $(seq 1 100); do
  # Get products
  wget -q -O- http://product-service:8080/api/products
  
  # Add to cart
  wget -q -O- --post-data="{\"productId\":\"1\",\"quantity\":1}" \
    --header="Content-Type: application/json" \
    http://cart-service:8080/api/cart/user$i/items
  
  # Create order
  wget -q -O- --post-data="{\"userId\":\"$i\",\"items\":[{\"productId\":\"1\",\"price\":999,\"quantity\":1}]}" \
    --header="Content-Type: application/json" \
    http://order-service:8080/api/orders
  
  sleep 0.5
done
'
```

## Key Metrics to Monitor

### Service Health
- **Request Rate**: Should be consistent with expected traffic
- **Error Rate**: < 1% under normal conditions
- **P99 Latency**: < 500ms for most services
- **Saturation**: CPU < 80%, Memory < 85%

### Circuit Breaker
- **Ejected Hosts**: 0 under normal conditions
- **Overflow**: Indicates circuit is open
- **Pending Requests**: Should not accumulate

### mTLS
- **Certificate Rotation**: Automatic every 90 days
- **All Services**: Should show "STRICT" mode
- **No Plaintext**: All traffic encrypted

## Troubleshooting Commands

```bash
# Check pod status
kubectl get pods -n ecommerce

# View logs with Envoy proxy logs
kubectl logs -n ecommerce deploy/order-service -c order-service --tail=100
kubectl logs -n ecommerce deploy/order-service -c istio-proxy --tail=100

# Check Envoy configuration
kubectl exec -n ecommerce deploy/product-service-v1 -c istio-proxy -- \
  pilot-agent request GET config_dump

# View active connections
kubectl exec -n ecommerce deploy/product-service-v1 -c istio-proxy -- \
  pilot-agent request GET stats | grep upstream_cx

# Check mTLS certificates
kubectl exec -n ecommerce deploy/product-service-v1 -c istio-proxy -- \
  pilot-agent request GET certs

# Restart pods with issues
kubectl rollout restart deployment/order-service -n ecommerce

# Check Istio proxy sync status
istioctl proxy-status -n ecommerce
```

## Production Readiness Checklist

- [x] All services have health/readiness probes
- [x] mTLS enabled (STRICT mode)
- [x] Circuit breakers configured
- [x] Retry policies in place
- [x] Timeout policies configured
- [x] Resource limits set
- [x] Multiple replicas for HA
- [x] Monitoring and alerting (Grafana)
- [x] Distributed tracing (Jaeger)
- [x] Service mesh visualization (Kiali)
- [x] Canary deployment strategy
- [x] Fault injection testing

## Next Steps

1. **Add Authentication**: Implement JWT validation with Istio RequestAuthentication
2. **Rate Limiting**: Configure rate limits per user/service
3. **Egress Control**: Restrict external API calls
4. **Multi-cluster**: Set up Istio multi-cluster mesh
5. **GitOps**: Integrate with ArgoCD/Flux for automated deployments
6. **Alerts**: Configure Prometheus alerts for SLOs
7. **Service-level Objectives**: Define and monitor SLOs
8. **Backup Strategy**: Implement etcd backups and disaster recovery